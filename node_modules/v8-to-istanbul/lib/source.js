const CovLine = require('./line')
const { sliceRange } = require('./range')
const { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND } = require('source-map').SourceMapConsumer

module.exports = class CovSource {
  constructor (sourceRaw, wrapperLength) {
    sourceRaw = sourceRaw ? sourceRaw.trimEnd() : ''
    this.lines = []
    this.eof = sourceRaw.length
    this.shebangLength = getShebangLength(sourceRaw)
    this.wrapperLength = wrapperLength - this.shebangLength
    this._buildLines(sourceRaw)
  }

  _buildLines (source) {
    let position = 0
    let ignoreCount = 0
    let ignoreAll = false
    for (const [i, lineStr] of source.split(/(?<=\r?\n)/u).entries()) {
      const line = new CovLine(i + 1, position, lineStr)
      if (ignoreCount > 0) {
        line.ignore = true
        ignoreCount--
      } else if (ignoreAll) {
        line.ignore = true
      }
      this.lines.push(line)
      position += lineStr.length

      const ignoreToken = this._parseIgnore(lineStr)
      if (!ignoreToken) continue

      line.ignore = true
      if (ignoreToken.count !== undefined) {
        ignoreCount = ignoreToken.count
      }
      if (ignoreToken.start || ignoreToken.stop) {
        ignoreAll = ignoreToken.start
        ignoreCount = 0
      }
    }
  }

  /**
   * Parses for comments:
   *    c8 ignore next
   *    c8 ignore next 3
   *    c8 ignore start
   *    c8 ignore stop
   * @param {string} lineStr
   * @return {{count?: number, start?: boolean, stop?: boolean}|undefined}
   */
  _parseIgnore (lineStr) {
    const testIgnoreNextLines = lineStr.match(/^\W*\/\* c8 ignore next (?<count>[0-9]+) *\*\/\W*$/)
    if (testIgnoreNextLines) {
      return { count: Number(testIgnoreNextLines.groups.count) }
    }

    // Check if comment is on its own line.
    if (lineStr.match(/^\W*\/\* c8 ignore next *\*\/\W*$/)) {
      return { count: 1 }
    }

    if (lineStr.match(/\/\* c8 ignore next \*\//)) {
      // Won't ignore successive lines, but the current line will be ignored.
      return { count: 0 }
    }

    const testIgnoreStartStop = lineStr.match(/\/\* c8 ignore (?<mode>start|stop) *\*\//)
    if (testIgnoreStartStop) {
      if (testIgnoreStartStop.groups.mode === 'start') return { start: true }
      if (testIgnoreStartStop.groups.mode === 'stop') return { stop: true }
    }
  }

  // given a start column and end column in absolute offsets within
  // a source file (0 - EOF), returns the relative line column positions.
  offsetToOriginalRelative (sourceMap, startCol, endCol) {
    const lines = sliceRange(this.lines, startCol, endCol, true)
    if (!lines.length) return {}

    const start = originalPositionTryBoth(
      sourceMap,
      lines[0].line,
      Math.max(0, startCol - lines[0].startCol)
    )
    if (!(start 