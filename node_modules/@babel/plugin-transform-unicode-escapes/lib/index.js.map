{"version":3,"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","surrogate","unicodeEscape","escape","code","str","toString","length","replacer","match","backslashes","char","String","fromCodePoint","parseInt","escaped","slice","charCodeAt","replaceUnicodeEscapes","replace","getUnicodeEscape","exec","lastIndex","name","manipulateOptions","generatorOpts","_generatorOpts$jsescO","_generatorOpts$jsescO2","jsescOption","minimal","visitor","Identifier","path","node","key","replaced","c","t","inherits","stringLiteral","replaceWith","parentPath","scope","isMemberExpression","property","isOptionalMemberExpression","computed","binding","getBinding","rename","generateUid","buildCodeFrameError","StringLiteral|DirectiveLiteral","extra","raw","TemplateElement","value","firstEscape","grandParent","isTaggedTemplateExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const surrogate = /[\\ud800-\\udfff]/g;\n  const unicodeEscape = /(\\\\+)u\\{([0-9a-fA-F]+)\\}/g;\n\n  function escape(code: number) {\n    if (process.env.BABEL_8_BREAKING) {\n      return \"\\\\u\" + code.toString(16).padStart(4, \"0\");\n    } else {\n      let str = code.toString(16);\n      while (str.length < 4) str = \"0\" + str;\n      return \"\\\\u\" + str;\n    }\n  }\n\n  function replacer(match: string, backslashes: string, code: string) {\n    if (backslashes.length % 2 === 0) {\n      return match;\n    }\n\n    const char = String.fromCodePoint(parseInt(code, 16));\n    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));\n\n    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));\n  }\n\n  function replaceUnicodeEscapes(str: string) {\n    return str.replace(unicodeEscape, replacer);\n  }\n\n  function getUnicodeEscape(str: string) {\n    let match;\n    while ((match = unicodeEscape.exec(str))) {\n      if (match[1].length % 2 === 0) continue;\n      unicodeEscape.lastIndex = 0;\n      return match[0];\n    }\n    return null;\n  }\n\n  return {\n    name: \"transform-unicode-escapes\",\n    manipulateOptions({ generatorOpts }) {\n      // Babel 8 will enable jsesc minimal mode by default, which outputs\n      // unescaped unicode string\n      if (!generatorOpts.jsescOption) {\n        generatorOpts.jsescOption = {};\n      }\n      generatorOpts.jsescOption.minimal ??= false;\n    },\n    visitor: {\n      Identifier(path) {\n        const { node, key } = path;\n        const { name } = node;\n        const replaced = name.replace(surrogate, c => {\n          return `_u${c.charCodeAt(0).toString(16)}`;\n        });\n        if (name === replaced) return;\n\n        const str = t.inherits(t.stringLiteral(name), node);\n\n        if (key === \"key\") {\n          path.replaceWith(str);\n          return;\n        }\n\n        const { parentPath, scope } = path;\n        if (\n          parentPath.isMemberExpression({ property: node }) ||\n          parentPath.isOptionalMemberExpression({ property: node })\n        ) {\n          parentPath.node.computed = true;\n          path.replaceWith(str);\n          return;\n        }\n\n        const binding = scope.getBinding(name);\n        if (binding) {\n          scope.rename(name, scope.generateUid(replaced));\n          return;\n        }\n\n        throw path.buildCodeFrameError(\n          `Can't reference '${name}' as a bare identifier`,\n        );\n      },\n\n      \"StringLiteral|DirectiveLiteral\"(\n        path: NodePath<t.StringLiteral | t.DirectiveLiteral>,\n      ) {\n        const { node } = path;\n        const { extra } = node;\n\n        if (extra?.raw) extra.raw = replaceUnicodeEscapes(extra.raw as string);\n      },\n\n      TemplateElement(path) {\n        const { node, parentPath } = path;\n        const { value } = node;\n\n        const firstEscape = getUnicodeEscape(value.raw);\n        if (!firstEscape) return;\n\n        const grandParent = parentPath.parentPath;\n        if (grandParent.isTaggedTemplateExpression()) {\n          throw path.buildCodeFrameError(\n            `Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`,\n          );\n        }\n\n        value.raw = replaceUnicodeEscapes(value.raw);\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAG1B,IAAAC,0BAAO,EAACC,GAAG,IAAI;EAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;EAEtC,MAAMC,SAAS,GAAG,kBAAkB;EACpC,MAAMC,aAAa,GAAG,2BAA2B;EAEjD,SAASC,MAAMA,CAACC,IAAY,EAAE;IAGrB;MACL,IAAIC,GAAG,GAAGD,IAAI,CAACE,QAAQ,CAAC,EAAE,CAAC;MAC3B,OAAOD,GAAG,CAACE,MAAM,GAAG,CAAC,EAAEF,GAAG,GAAG,GAAG,GAAGA,GAAG;MACtC,OAAO,KAAK,GAAGA,GAAG;IACpB;EACF;EAEA,SAASG,QAAQA,CAACC,KAAa,EAAEC,WAAmB,EAAEN,IAAY,EAAE;IAClE,IAAIM,WAAW,CAACH,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MAChC,OAAOE,KAAK;IACd;IAEA,MAAME,IAAI,GAAGC,MAAM,CAACC,aAAa,CAACC,QAAQ,CAACV,IAAI,EAAE,EAAE,CAAC,CAAC;IACrD,MAAMW,OAAO,GAAGL,WAAW,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAGb,MAAM,CAACQ,IAAI,CAACM,UAAU,CAAC,CAAC,CAAC,CAAC;IAErE,OAAON,IAAI,CAACJ,MAAM,KAAK,CAAC,GAAGQ,OAAO,GAAGA,OAAO,GAAGZ,MAAM,CAACQ,IAAI,CAACM,UAAU,CAAC,CAAC,CAAC,CAAC;EAC3E;EAEA,SAASC,qBAAqBA,CAACb,GAAW,EAAE;IAC1C,OAAOA,GAAG,CAACc,OAAO,CAAC