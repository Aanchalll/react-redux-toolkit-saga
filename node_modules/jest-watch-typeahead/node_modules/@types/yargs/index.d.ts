// The following TSLint rules have been disabled:
// unified-signatures: Because there is useful information in the argument names of the overloaded signatures

// Convention:
// Use 'union types' when:
//  - parameter types have similar signature type (i.e. 'string | ReadonlyArray<string>')
//  - parameter names have the same semantic meaning (i.e. ['command', 'commands'] , ['key', 'keys'])
//    An example for not using 'union types' is the declaration of 'env' where `prefix` and `enable` parameters
//    have different semantics. On the other hand, in the declaration of 'usage', a `command: string` parameter
//    has the same semantic meaning with declaring an overload method by using `commands: ReadonlyArray<string>`,
//    thus it's preferred to use `command: string | ReadonlyArray<string>`
// Use parameterless declaration instead of declaring all parameters optional,
// when all parameters are optional and more than one

import { Configuration, DetailedArguments } from "yargs-parser";

declare namespace yargs {
    type BuilderCallback<T, R> =
        | ((args: Argv<T>) => PromiseLike<Argv<R>>)
        | ((args: Argv<T>) => Argv<R>)
        | ((args: Argv<T>) => void);

    type ParserConfigurationOptions = Configuration & {
        /** Sort commands alphabetically. Default is `false` */
        "sort-commands": boolean;
    };

    /**
     * The type parameter `T` is the expected shape of the parsed options.
     * `Arguments<T>` is those options plus `_` and `$0`, and an indexer falling
     * back to `unknown` for unknown options.
     *
     * For the return type / `argv` property, we create a mapped type over
     * `Arguments<T>` to simplify the inferred type signature in client code.
     */
    interface Argv<T = {}> {
        (args?: readonly string[] | string, cwd?: string): Argv<T>;

        /**
         * Set key names as equivalent such that updates to a key will propagate to aliases and vice-versa.
         *
         * Optionally `.alias()` can take an object that maps keys to aliases.
         * Each key of this object should be the canonical version of the option, and each value should be a string or an array of strings.
         */
        // Aliases for previously declared options can inherit the types of those options.
        alias<K1 extends keyof T, K2 extends string>(
            shortName: K1,
            longName: K2 | readonly K2[],
        ): Argv<T & { [key in K2]: T[K1] }>;
        alias<K1 extends keyof T, K2 extends string>(
            shortName: K2,
            longName: K1 | readonly K1[],
        ): Argv<T & { [key in K2]: T[K1] }>;
        alias(shortName: string | readonly string[], longName: string | readonly string[]): Argv<T>;
        alias(aliases: { [shortName: string]: string | readonly string[] }): Argv<T>;

        /**
         * Get the arguments as a plain old object.
         *
         * Arguments without a corresponding flag show up in the `argv._` array.
         *
         * The script name or node command is available at `argv.$0` similarly to how `$0` works in bash or perl.
         *
         * If `yargs` is executed in an environment that embeds node and there's no script name (e.g. Electron or nw.js),
         * it will ignore the first parameter since it expects it to be the script name. In order to override
         * this behavior, use `.parse(process.argv.slice(1))` instead of .argv and the first parameter won't be ignored.
         */
        argv:
            | { [key in keyof Arguments<T> as key | CamelCaseKey<key>]: Arguments<T>[key] }
            | Promise<{ [key in keyof Arguments<T> as key | CamelCaseKey<key>]: Arguments<T>[key] }>;

        /**
         * Tell the parser to interpret `key` as an array.
         * If `.array('foo')` is set, `--foo foo bar` will be parsed as `['foo', 'bar']` rather than as `'foo'`.
         * Also, if you use the option multiple times all the values will be flattened in one array so `--foo foo --foo bar` will be parsed as `['foo', 'bar']`
         *
         * When the option is used with a positional, use `--` to tell `yargs` to stop adding values to the array.
         */
        array<K extends keyof T>(key: K | readonly K[]): Argv<Omit<T, K> & { [key in K]: ToArray<T[key]> }>;
        array<K extends string>(
            key: K | readonly K[],
        ): Argv<T & { [key in K]: Array<string | number> | undefined }>;

        /**
         * Interpret `key` as a boolean. If a non-flag option follows `key` in `process.argv`, that string won't get set as the value of `key`.
         *
         * `key` will default to `false`, unless a `default(key, undefined)` is explicitly set.
         *
         * If `key` is an array, interpret all the elements as booleans.
         */
        boolean<K extends keyof T>(key: K | readonly K[]): Argv<Omit<T, K> & { [key in K]: boolean | undefined }>;
        boolean<K extends string>(key: K | readonly K[]): Argv<T & { [key in K]: boolean | undefined }>;

        /**
         * Check that certain conditions are met in the provided arguments.
         * @param func Called with two arguments, the parsed `argv` hash and an array of options and their aliases.
         * If `func` throws or returns a non-truthy value, show the thrown error, usage information, and exit.
         * @param global Indicates whether `check()` should be enabled both at the top-level and for each sub-command.
         */
        check(func: (argv: Arguments<T>, aliases: { [alias: string]: string }) => any, global?: boolean): Argv<T>;

        /**
         * Limit valid values for key to a predefined set of choices, given as an array or as an individual value.
         * If this method is called multiple times, all enumerated values will be merged together.
         * Choices are generally strings or numbers, and value matching is case-sensitive.
         *
         * Optionally `.choices()` can take an object that maps multiple keys to their choices.
         *
         * Choices can also be specified as choices in the object given to `option()`.
         */
        choices<K extends keyof T, C extends readonly any[]>(
            key: K,
            values: C,
        ): Argv<Omit<T, K> & { [key in K]: C[number] | undefined }>;
        choices<K extends string, C extends readonly any[]>(
            key: K,
            values: C,
        ): Argv<T & { [key in K]: C[number] | undefined }>;
        choices<C extends { [key: string]: readonly any[] }>(
            choices: C,
        ): Argv<Omit<T, keyof C> & { [key in keyof C]: C[key][number] | undefined }>;

        /**
         * Provide a synchronous function to coerce or transform the value(s) given on the command line for `key`.
         *
         * The coercion function should accept one argument, representing the parsed value from the command line, and should return a new value or throw an error.
         * The returned value will be used as the value for `key` (or one of its aliases) in `argv`.
         *
         * If the function throws, the error will be treated as a validation failure, delegating to either a custom `.fail()` handler or printing the error message in the console.
         *
         * Coercion will be applied to a value after all other modifications, such as `.normalize()`.
         *
         * Optionally `.coerce()` can take an object that maps several keys to their respective coercion function.
         *
         * You can also map the same function to several keys at one time. Just pass an array of keys as the first argument to `.coerce()`.
         *
         * If you are using dot-notion or arrays, .e.g., `user.email` and `user.password`, coercion will be applied to the final object that has been parsed
         */
        coerce<K extends keyof T, V>(
            key: K | readonly K[],
            func: (arg: any) => V,
        ): Argv<Omit<T, K> & { [key in K]: V | undefined }>;
        coerce<K extends string, V>(
            key: K | readonly K[],
            func: (arg: any) => V,
        ): Argv<T & { [key in K]: V | undefined }>;
        coerce<O extends { [key: string]: (arg: any) => any }>(
            opts: O,
        ): Argv<Omit<T, keyof O> & { [key in keyof O]: ReturnType<O[key]> | undefined }>;

        /**
         * Define the commands exposed by your application.
         * @param command Should be a string representing the command or an array of strings representing the command and its aliases.
         * @param description Use to provide a description for each command your application accepts (the values stored in `argv._`).
         * Set `description` to false to create a hidden command. Hidden commands don't show up in the help output and aren't available for completion.
         * @param [builder] Object to give hints about the options that your command accepts.
         * Can also be a function. This function is executed with a yargs instance, and can be used to provide advanced command specific help.
         *
         * Note that when `void` is returned, the handler `argv` object type will not include command-specific arguments.
         * @param [handler] Function, which will be executed with the parsed `argv` object.
         */
        command<U = T>(
            command: string | readonly string[],
            description: string,
            builder?: BuilderCallback<T, U>,
            handler?: (args: ArgumentsCamelCase<U>) => void | Promise<void>,
            middlewares?: Array<MiddlewareFunction<U>>,
            deprecated?: boolean | string,
        ): Argv<T>;
        command<O extends { [key: string]: Options }>(
            command: string | readonly string[],
            description: string,
            builder?: O,
            handler?: (args: ArgumentsCamelCase<InferredOptionTypes<O>>) => void | Promise<void>,
            middlewares?: Array<MiddlewareFunction<O>>,
            deprecated?: boolean | string,
        ): Argv<T>;
        command<U = any>( // eslint-disable-line @definitelytyped/no-unnecessary-generics
            command: string | readonly string[],
            description: string,
            module: CommandModule<T, U>,
        ): Argv<T>;
        command<U = T>(
            command: string | readonly string[],
            showInHelp: false,
            builder?: BuilderCallback<T, U>,
            handler?: (args: ArgumentsCamelCase<U>) => void | Promise<void>,
            middlewares?: Array<MiddlewareFunction<U>>,
            deprecated?: boolean | string,
        ): Argv<T>;
        command<O extends { [key: string]: Options }>(
            command: string | readonly string[],
            showInHelp: false,
            builder?: O,
            handler?: (args: ArgumentsCamelCase<InferredOptionTypes<O>>) => void | Promise<void>,
        ): Argv<T>;
        command<U = any>( // eslint-disable-line @definitelytyped/no-unnecessary-generics
            command: string | readonly string[],
            showInHelp: false,
            module: CommandModule<T, U>,
        ): Argv<T>;
        // eslint-disable-next-line @definitelytyped/no-unnecessary-generics
        command<U = any>(module: CommandModule<T, U>): Argv<T>;
        // eslint-disable-next-line @definitelytyped/no-unnecessary-generics
        command<U = any>(modules: Array<CommandModule<T, U>>): Argv<T>;

        // Advanced API
        /** Apply command modules from a directory relative to the module calling this method. */
        commandDir(dir: string, opts?: RequireDirectoryOptions): Argv<T>;

        /**
         * Enable bash/zsh-completion shortcuts for commands and options.
         *
         * If invoked without parameters, `.completion()` will make completion the command to output the completion script.
         *
         * @param [cmd] When present in `argv._`, will result in the `.bashrc` or `.zshrc` completion script being outputted.
         * To enable bash/zsh completions, concat the generated script to your `.bashrc` or `.bash_profile` (or `.zshrc` for zsh).
         * @param [description] Provide a description in your usage instructions for the command that generates the completion scripts.
         * @param [func] Rather than relying on yargs' default completion functionality, which shiver me timbers is pretty awesome, you can provide your own completion method.
         */
        completion(): Argv<T>;
        completion(cmd: string, func?: AsyncCompletionFunction): Argv<T>;
        completion(cmd: string, func?: SyncCompletionFunction): Argv<T>;
        completion(cmd: string, func?: PromiseCompletionFunction): Argv<T>;
        completion(cmd: string, func?: FallbackCompletionFunction): Argv<T>;
        completion(cmd: string, description?: string | false, func?: AsyncCompletionFunction): Argv<T>;
        completion(cmd: string, description?: string | false, func?: SyncCompletionFunction): Argv<T>;
        completion(cmd: string, description?: string | false, func?: PromiseCompletionFunction): Argv<T>;
        completion(cmd: string, description?: string | false, func?: FallbackCompletionFunction): Argv<T>;

        /**
         * Tells the parser that if the option specified by `key` is passed in, it should be interpreted as a path to a JSON config file.
         * The file is loaded and parsed, and its properties are set as arguments.
         * Because the file is loaded using Node's require(), the filename MUST end in `.json` to be interpreted correctly.
         *
         * If invoked without parameters, `.config()` will make --config the option to pass the JSON config file.
         *
         * @param [description] Provided to customize the config (`key`) option in the usage string.
         * @param [explicitConfigurationObject] An explicit configuration `object`
         */
        config(): Argv<T>;
        config(
            key: string | readonly string[],
            description?: string,
            parseFn?: (configPath: string) => object,
        ): Argv<T>;
        config(key: string | readonly string[], parseFn: (configPath: string) => object): Argv<T>;
        config(explicitConfigurationObject: object): Argv<T>;

        /**
         * Given the key `x` is set, the key `y` must not be set. `y` can either be a single string or an array of argument names that `x` conflicts with.
         *
         * Optionally `.conflicts()` can accept an object specifying multiple conflicting keys.
         */
        conflicts(key: string, value: string | readonly string[]): Argv<T>;
        conflicts(conflicts: { [key: string]: string | readonly string[] }): Argv<T>;

        /**
         * Interpret `key` as a boolean flag, but set its parsed value to the number of flag occurrences rather than `true` or `false`. Default value is thus `0`.
         */
        count<K extends keyof T>(key: K | readonly K[]): Argv<Omit<T, K> & { [key in K]: number }>;
        count<K extends string>(key: K | readonly K[]): Argv<T & { [key in K]: number }>;

        /**
         * Set `argv[key]` to `value` if no option was specified in `process.argv`.
         *
         * Optionally `.default()` can take an object that maps keys to default values.
         *
         * The default value can be a `function` which returns a value. The name of the function will be used in the usage string.
         *
         * Optionally, `description` can also be provided and will take precedence over displaying the value in the usage instructions.
         */
        default<K extends keyof T, V>(key: K, value: V, description?: string): Argv<Omit<T, K> & { [key in K]: V }>;
        default<K extends string, V>(key: K, value: V, description?: string): Argv<T & { [key in K]: V }>;
        default<D extends { [key: string]: any }>(defaults: D, description?: string): Argv<Omit<T, keyof D> & D>;

        /**
         * @deprecated since version 6.6.0
         * Use '.demandCommand()' or '.demandOption()' instead
         */
        demand<K extends keyof T>(key: K | readonly K[], msg?: string | true): Argv<Defined<T, K>>;
        demand<K extends string>(key: K | readonly K[], msg?: string | true): Argv<T & { [key in K]: unknown }>;
        demand(key: string | readonly string[], required?: boolean): Argv<T>;
        demand(positionals: number, msg: string): Argv<T>;
        demand(positionals: number, required?: boolean): Argv<T>;
        demand(positionals: number, max: number, msg?: string): Argv<T>;

        /**
         * @param key If is a string, show the usage information and exit if key wasn't specified in `process.argv`.
         * If is an array, demand each element.
         * @param msg If string is given, it will be printed when the argument is missing, instead of the standard error message.
         * @param demand Controls whether the option is demanded; this is useful when using .options() to specify command line parameters.
         */
        demandOption<K extends keyof T>(key: K | readonly K[], msg?: string | true): Argv<Defined<T, K>>;
        demandOption<K extends string>(
            key: K | readonly K[],
            msg?: string | true,
        ): Argv<T & { [key in K]: unknown }>;
        demandOption(key: string | readonly string[], demand?: boolean): Argv<T>;

        /**
         * Demand in context of commands.
         * You can demand a minimum and a maximum number a user can have within your program, as well as provide corresponding error messages if either of the demands is not met.
         */
        demandCommand(): Argv<T>;
        demandCommand(min: number, minMsg?: string): Argv<T>;
        demandCommand(min: number, max?: number, minMsg?: string, maxMsg?: string): Argv<T>;

        /**
         * Shows a [deprecated] notice in front of the option
         */
        deprecateOption(option: string, msg?: string): Argv<T>;

        /**
         * Describe a `key` for the generated usage information.
         *
         * Optionally `.describe()` can take an object that maps keys to descriptions.
         */
        describe(key: string | readonly string[], description: string): Argv<T>;
        describe(descriptions: { [key: string]: string }): Argv<T>;

        /** Should yargs attempt to detect the os' locale? Defaults to `true`. */
        detectLocale(detect: boolean): Argv<T>;

        /**
         * Tell yargs to parse environment variables matching the given prefix and apply them to argv as though they were command line arguments.
         *
         * Use the "__" separator in the environment variable to indicate nested options. (e.g. prefix_nested__foo => nested.foo)
         *
         * If this method is called with no argument or with an empty string or with true, then all env vars will be applied to argv.
         *
         * Program arguments are defined in this order of precedence:
         * 1. Command line args
         * 2. Env vars
         * 3. Config file/objects
         * 4. Configured defaults
         *
         * Env var parsing is disabled by default, but you can also explicitly disable it by calling `.env(false)`, e.g. if you need to undo previous configuration.
         */
        env(): Argv<T>;
        env(prefix: string): Argv<T>;
        env(enable: boolean): Argv<T>;

        /** A message to print at the end of the usage instructions */
        epilog(msg: string): Argv<T>;
        /** A message to print at the end of the usage instructions */
        epilogue(msg: string): Argv<T>;

        /**
         * Give some example invocations of your program.
         * Inside `cmd`, the string `$0` will get interpolated to the current script name or node command for the present script similar to how `$0` works in bash or perl.
         * Examples will be printed out as part of the help message.
         */
        example(command: string, description: string): Argv<T>;
        example(command: ReadonlyArray<[string, string?]>): Argv<T>;

        /** Manually indicate that the program should exit, and provide context about why we wanted to exit. Follows the behavior set by `.exitProcess().` */
        exit(code: number, err: Error): void;

        /**
         * By default, yargs exits the process when the user passes a help flag, the user uses the `.version` functionality, validation fails, or the command handler fails.
         * Calling `.exitProcess(false)` disables this behavior, enabling further actions after yargs have been validated.
         */
        exitProcess(enabled: boolean): Argv<T>;

        /**
         * Method to execute when a failure occurs, rather than printing the failure message.
         * @param func Is called with the failure message that would have been printed, the Error instance originally thrown and yargs state when the failure occurred.
         */
        fail(func: ((msg: string, err: Error, yargs: Argv<T>) => any) | boolean): Argv<T>;

        /**
         * Allows to programmatically get completion choices for any line.
         * @param args An array of the words in the command line to complete.
         * @param done The callback to be called with the resulting completions.
         */
        getCompletion(
            args: readonly string[],
            done: (err: Error | null, completions: readonly string[]) => void,
        ): Argv<T>;
        getCompletion(args: readonly string[], done?: never): Promise<readonly string[]>;

        /**
         * Returns a promise which resolves to a string containing the help text.
         */
        getHelp(): Promise<string>;

        /**
         * Indicate that an option (or group of options) should not be reset when a command is executed
         *
         * Options default to being global.
         */
        global(key: string | readonly string[]): Argv<T>;

        /** Given a key, or an array of keys, pla